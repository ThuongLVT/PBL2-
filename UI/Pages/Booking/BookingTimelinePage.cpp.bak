#include "BookingTimelinePage.h"
#include <QMessageBox>
#include <QHeaderView>
#include <QFrame>
#include <QGroupBox>
#include <QTime>

BookingTimelinePage::BookingTimelinePage(QuanLySan *qlSan, 
                                           QuanLyDatSan *qlDatSan, 
                                           QuanLyKhachHang *qlKH,
                                           QWidget *parent)
    : QWidget(parent)
    , m_quanLySan(qlSan)
    , m_quanLyDatSan(qlDatSan)
    , m_quanLyKhachHang(qlKH)
    , m_selectedDate(QDate::currentDate())
    , m_selectedTimeSlot(-1)
{
    setObjectName("BookingTimelinePage");
    
    // T·∫°o time slots t·ª´ 6:00 ƒë·∫øn 22:00 (30 ph√∫t m·ªói slot)
    for (int hour = 6; hour < 22; hour++) {
        m_timeSlots << QString("%1:00").arg(hour, 2, 10, QChar('0'));
        m_timeSlots << QString("%1:30").arg(hour, 2, 10, QChar('0'));
    }
    
    setupUI();
    setupConnections();
    applyStyles();
    loadFieldsData();
    loadBookingsData();
    updateTimeline();
}

BookingTimelinePage::~BookingTimelinePage()
{
}

// ========== SETUP FUNCTIONS ==========

void BookingTimelinePage::setupUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(0);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    
    // Splitter ƒë·ªÉ chia 40-60
    QSplitter *splitter = new QSplitter(Qt::Vertical, this);
    
    // Top section (40%)
    m_topWidget = new QWidget();
    setupTopSection();
    splitter->addWidget(m_topWidget);
    
    // Bottom section (60%)
    m_bottomWidget = new QWidget();
    setupBottomSection();
    splitter->addWidget(m_bottomWidget);
    
    // Set t·ª∑ l·ªá 40-60
    splitter->setStretchFactor(0, 40);
    splitter->setStretchFactor(1, 60);
    
    mainLayout->addWidget(splitter);
}

void BookingTimelinePage::setupTopSection()
{
    QHBoxLayout *topLayout = new QHBoxLayout(m_topWidget);
    topLayout->setSpacing(10);
    topLayout->setContentsMargins(20, 20, 20, 10);
    
    // Left: Calendar (25%)
    QWidget *calendarWidget = new QWidget();
    calendarWidget->setStyleSheet("QWidget { background-color: white; border-radius: 8px; }");
    QVBoxLayout *calendarLayout = new QVBoxLayout(calendarWidget);
    calendarLayout->setContentsMargins(10, 10, 10, 10);
    
    m_calendar = new QCalendarWidget();
    m_calendar->setSelectedDate(m_selectedDate);
    m_calendar->setGridVisible(true);
    m_calendar->setVerticalHeaderFormat(QCalendarWidget::NoVerticalHeader); // B·ªè c·ªôt s·ªë tu·∫ßn
    calendarLayout->addWidget(m_calendar);
    
    // Right: Booking Form (75%)
    QWidget *formWidget = new QWidget();
    setupBookingForm();
    
    // Add to top layout
    topLayout->addWidget(calendarWidget, 25);
    topLayout->addWidget(formWidget, 75);
}

void BookingTimelinePage::setupBookingForm()
{
    QWidget *formWidget = m_topWidget->findChild<QWidget*>();
    if (!formWidget) {
        formWidget = new QWidget();
    }
    
    formWidget->setStyleSheet("QWidget { background-color: white; border-radius: 8px; }");
    QVBoxLayout *formLayout = new QVBoxLayout(formWidget);
    formLayout->setSpacing(15);
    formLayout->setContentsMargins(15, 15, 15, 15);
    formWidget->setMinimumHeight(400); // Ensure form is visible
    
    // Title
    QLabel *titleLabel = new QLabel("TH√îNG TIN ƒê·∫∂T S√ÇN");
    titleLabel->setStyleSheet("font-size: 16px; font-weight: bold; color: " + COLOR_PRIMARY + ";");
    formLayout->addWidget(titleLabel);
    
    // Form fields container
    QWidget *fieldsContainer = new QWidget();
    QGridLayout *gridLayout = new QGridLayout(fieldsContainer);
    gridLayout->setSpacing(10);
    gridLayout->setContentsMargins(0, 0, 0, 0);
    
    int row = 0;
    
    // Phone + Search
    QLabel *phoneLabel = new QLabel("S·ªë ƒêi·ªán Tho·∫°i:");
    m_phoneEdit = new QLineEdit();
    m_phoneEdit->setPlaceholderText("Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i kh√°ch h√†ng");
    m_phoneSearchBtn = new QPushButton("üîç");
    m_phoneSearchBtn->setFixedWidth(40);
    
    gridLayout->addWidget(phoneLabel, row, 0);
    QHBoxLayout *phoneLayout = new QHBoxLayout();
    phoneLayout->addWidget(m_phoneEdit);
    phoneLayout->addWidget(m_phoneSearchBtn);
    gridLayout->addLayout(phoneLayout, row, 1);
    row++;
    
    // Name
    QLabel *nameLabel = new QLabel("T√™n Kh√°ch H√†ng:");
    m_nameEdit = new QLineEdit();
    m_nameEdit->setPlaceholderText("T√™n kh√°ch h√†ng");
    gridLayout->addWidget(nameLabel, row, 0);
    gridLayout->addWidget(m_nameEdit, row, 1);
    row++;
    
    // Price
    QLabel *priceLabel = new QLabel("Gi√° S√¢n:");
    m_priceEdit = new QLineEdit();
    m_priceEdit->setPlaceholderText("300,000 VNƒê");
    m_priceEdit->setReadOnly(true);
    gridLayout->addWidget(priceLabel, row, 0);
    gridLayout->addWidget(m_priceEdit, row, 1);
    row++;
    
    // Status
    QLabel *statusLabel = new QLabel("Tr·∫°ng Th√°i:");
    m_statusCombo = new QComboBox();
    m_statusCombo->addItems({"ƒêang ho·∫°t ƒë·ªông", "Ch·ªù x√°c nh·∫≠n", "ƒê√£ x√°c nh·∫≠n", "ƒê√£ h·ªßy"});
    gridLayout->addWidget(statusLabel, row, 0);
    gridLayout->addWidget(m_statusCombo, row, 1);
    row++;
    
    // Field Type
    QLabel *typeLabel = new QLabel("Lo·∫°i S√¢n:");
    m_fieldTypeCombo = new QComboBox();
    m_fieldTypeCombo->addItems({"S√¢n 5 ng∆∞·ªùi", "S√¢n 7 ng∆∞·ªùi"});
    gridLayout->addWidget(typeLabel, row, 0);
    gridLayout->addWidget(m_fieldTypeCombo, row, 1);
    row++;
    
    // Field Selection
    QLabel *fieldLabel = new QLabel("Ch·ªçn S√¢n:");
    m_fieldCombo = new QComboBox();
    gridLayout->addWidget(fieldLabel, row, 0);
    gridLayout->addWidget(m_fieldCombo, row, 1);
    row++;
    
    // Date + Time
    QLabel *dateLabel = new QLabel("Ng√†y:");
    m_dateEdit = new QDateEdit();
    m_dateEdit->setDate(m_selectedDate);
    m_dateEdit->setCalendarPopup(true);
    m_dateEdit->setDisplayFormat("dd/MM/yyyy");
    gridLayout->addWidget(dateLabel, row, 0);
    gridLayout->addWidget(m_dateEdit, row, 1);
    row++;
    
    QLabel *fromLabel = new QLabel("Gi·ªù B·∫Øt ƒê·∫ßu:");
    m_fromTimeEdit = new QTimeEdit();
    m_fromTimeEdit->setTime(QTime(6, 0));
    m_fromTimeEdit->setDisplayFormat("HH:mm");
    gridLayout->addWidget(fromLabel, row, 0);
    gridLayout->addWidget(m_fromTimeEdit, row, 1);
    row++;
    
    QLabel *toLabel = new QLabel("Gi·ªù K·∫øt Th√∫c:");
    m_toTimeEdit = new QTimeEdit();
    m_toTimeEdit->setTime(QTime(8, 0));
    m_toTimeEdit->setDisplayFormat("HH:mm");
    gridLayout->addWidget(toLabel, row, 0);
    gridLayout->addWidget(m_toTimeEdit, row, 1);
    row++;
    
    m_durationLabel = new QLabel("Th·ªùi L∆∞·ª£ng: 2h");
    m_durationLabel->setStyleSheet("color: " + COLOR_PRIMARY + "; font-weight: bold;");
    gridLayout->addWidget(m_durationLabel, row, 1);
    row++;
    
    // Note
    QLabel *noteLabel = new QLabel("Ghi Ch√∫:");
    m_noteEdit = new QTextEdit();
    m_noteEdit->setPlaceholderText("Nh·∫≠p ghi ch√∫...");
    m_noteEdit->setMaximumHeight(80);
    gridLayout->addWidget(noteLabel, row, 0, Qt::AlignTop);
    gridLayout->addWidget(m_noteEdit, row, 1);
    row++;
    
    formLayout->addWidget(fieldsContainer);
    
    // Buttons
    QHBoxLayout *buttonLayout = new QHBoxLayout();
    buttonLayout->setSpacing(10);
    
    m_saveBtn = new QPushButton("‚úì L∆∞u");
    m_deleteBtn = new QPushButton("üóë X√≥a");
    m_checkInBtn = new QPushButton("‚öΩ Check-in / Thi ƒê·∫•u");
    
    m_saveBtn->setMinimumHeight(40);
    m_deleteBtn->setMinimumHeight(40);
    m_checkInBtn->setMinimumHeight(40);
    
    buttonLayout->addWidget(m_saveBtn);
    buttonLayout->addWidget(m_deleteBtn);
    buttonLayout->addStretch();
    
    formLayout->addLayout(buttonLayout);
    formLayout->addWidget(m_checkInBtn);
    formLayout->addStretch();
    
    // Replace formWidget in parent layout
    QHBoxLayout *parentLayout = qobject_cast<QHBoxLayout*>(m_topWidget->layout());
    if (parentLayout && parentLayout->count() == 1) {
        parentLayout->addWidget(formWidget, 75);
    }
}

void BookingTimelinePage::setupBottomSection()
{
    QVBoxLayout *bottomLayout = new QVBoxLayout(m_bottomWidget);
    bottomLayout->setSpacing(0);
    bottomLayout->setContentsMargins(20, 10, 20, 20);
    
    // Container v·ªõi n·ªÅn tr·∫Øng cho timeline
    QWidget *timelineContainer = new QWidget();
    timelineContainer->setStyleSheet("QWidget { background-color: white; border-radius: 8px; }");
    QVBoxLayout *containerLayout = new QVBoxLayout(timelineContainer);
    containerLayout->setContentsMargins(10, 10, 10, 10);
    
    // Timeline (no title)
    setupTimeline();
    containerLayout->addWidget(m_timelineScroll);
    bottomLayout->addWidget(timelineContainer);
}

void BookingTimelinePage::setupTimeline()
{
    m_timelineScroll = new QScrollArea();
    m_timelineScroll->setWidgetResizable(true);
    m_timelineScroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    m_timelineScroll->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    
    m_timelineTable = new DraggableTimelineTable();
    m_timelineTable->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_timelineTable->setSelectionMode(QAbstractItemView::SingleSelection);
    m_timelineTable->horizontalHeader()->setSectionResizeMode(QHeaderView::Fixed);
    m_timelineTable->verticalHeader()->setSectionResizeMode(QHeaderView::Fixed);
    m_timelineTable->verticalHeader()->setVisible(false); // Hide row numbers
    m_timelineTable->horizontalHeader()->setDefaultSectionSize(120);
    m_timelineTable->verticalHeader()->setDefaultSectionSize(40); // Height for 30-min slots
    
    createTimelineGrid();
    
    m_timelineScroll->setWidget(m_timelineTable);
}

void BookingTimelinePage::createTimelineGrid()
{
    // S·ªë h√†ng = s·ªë time slots (6:00 - 22:00, 30 ph√∫t/slot = 32 slots)
    // S·ªë c·ªôt = 1 (Time Slot) + s·ªë s√¢n
    
    m_timelineTable->setRowCount(m_timeSlots.count());
    
    // T·∫°m th·ªùi set 1 c·ªôt time slot, s·∫Ω c·∫≠p nh·∫≠t khi load fields
    m_timelineTable->setColumnCount(1);
    
    // Header
    QStringList headers;
    headers << "Time Slot";
    m_timelineTable->setHorizontalHeaderLabels(headers);
    
    // Populate time slots
    populateTimeSlots();
}

void BookingTimelinePage::populateTimeSlots()
{
    for (int row = 0; row < m_timeSlots.count(); row++) {
        QTableWidgetItem *timeItem = new QTableWidgetItem();
        
        // Ch·ªâ hi·ªán gi·ªù ch·∫µn (6, 7, 8...), kh√¥ng hi·ªán :30
        if (row % 2 == 0) {
            timeItem->setText(m_timeSlots[row]);
        }
        
        timeItem->setTextAlignment(Qt::AlignCenter);
        timeItem->setFlags(timeItem->flags() & ~Qt::ItemIsSelectable);
        timeItem->setBackground(QBrush(QColor(COLOR_LIGHT_GRAY)));
        timeItem->setFont(QFont("Arial", 10, QFont::Bold));
        m_timelineTable->setItem(row, 0, timeItem);
    }
}

void BookingTimelinePage::setupConnections()
{
    connect(m_calendar, &QCalendarWidget::selectionChanged, this, [this]() {
        onDateChanged(m_calendar->selectedDate());
    });
    connect(m_phoneSearchBtn, &QPushButton::clicked, this, &BookingTimelinePage::onPhoneSearchClicked);
    connect(m_fieldTypeCombo, &QComboBox::currentTextChanged, this, &BookingTimelinePage::onFieldTypeChanged);
    connect(m_saveBtn, &QPushButton::clicked, this, &BookingTimelinePage::onSaveClicked);
    connect(m_deleteBtn, &QPushButton::clicked, this, &BookingTimelinePage::onDeleteClicked);
    connect(m_checkInBtn, &QPushButton::clicked, this, &BookingTimelinePage::onCheckInClicked);
    
    // Connect drag selection signal
    connect(m_timelineTable, &DraggableTimelineTable::timeRangeSelected, 
            this, &BookingTimelinePage::onTimeRangeSelected);
    
    // Auto update duration
    connect(m_fromTimeEdit, &QTimeEdit::timeChanged, [this]() {
        QTime from = m_fromTimeEdit->time();
        QTime to = m_toTimeEdit->time();
        int minutes = from.secsTo(to) / 60;
        int hours = minutes / 60;
        int mins = minutes % 60;
        m_durationLabel->setText(QString("Duration: %1h%2m").arg(hours).arg(mins, 2, 10, QChar('0')));
    });
    
    connect(m_toTimeEdit, &QTimeEdit::timeChanged, [this]() {
        QTime from = m_fromTimeEdit->time();
        QTime to = m_toTimeEdit->time();
        int minutes = from.secsTo(to) / 60;
        int hours = minutes / 60;
        int mins = minutes % 60;
        m_durationLabel->setText(QString("Duration: %1h%2m").arg(hours).arg(mins, 2, 10, QChar('0')));
    });
}

void BookingTimelinePage::applyStyles()
{
    // Main widget with light gray background for content
    setStyleSheet(QString(
        "QWidget#BookingTimelinePage { background-color: %6; }" // Light gray background
        "QWidget { background-color: %1; color: %2; }"
        "QLineEdit, QComboBox, QTextEdit, QDateEdit, QTimeEdit { "
        "  border: 1px solid %3; "
        "  border-radius: 4px; "
        "  padding: 8px; "
        "  background-color: %1; "
        "}"
        "QLineEdit:focus, QComboBox:focus, QTextEdit:focus { "
        "  border: 2px solid %4; "
        "}"
        "QPushButton { "
        "  background-color: %4; "
        "  color: white; "
        "  border: none; "
        "  border-radius: 4px; "
        "  padding: 10px 20px; "
        "  font-weight: bold; "
        "}"
        "QPushButton:hover { "
        "  background-color: #45a049; "
        "}"
        "QPushButton:pressed { "
        "  background-color: #3d8b40; "
        "}"
        "QTableWidget { "
        "  background-color: white; "
        "  gridline-color: #E8E8E8; "
        "  border: none; "
        "  border-top: 1px solid %3; "
        "}"
        "QTableWidget::item { "
        "  border-right: 1px solid #E8E8E8; "
        "  border-bottom: 1px solid #E8E8E8; "
        "  padding: 5px; "
        "}"
        "QTableWidget::item:hover { "
        "  background-color: %5; "
        "}"
        "QHeaderView::section { "
        "  background-color: %6; "
        "  color: %2; "
        "  padding: 8px; "
        "  border: 1px solid %3; "
        "  font-weight: bold; "
        "}"
        "QCalendarWidget QWidget { "
        "  background-color: %1; "
        "}"
        "QCalendarWidget QAbstractItemView:enabled { "
        "  background-color: %1; "
        "  selection-background-color: %4; "
        "  selection-color: white; "
        "}"
        "QCalendarWidget QToolButton { "
        "  background-color: %1; "
        "  color: %2; "
        "}"
    ).arg(COLOR_BACKGROUND)
     .arg(COLOR_TEXT)
     .arg(COLOR_BORDER)
     .arg(COLOR_PRIMARY)
     .arg(COLOR_HOVER)
     .arg(COLOR_LIGHT_GRAY));
}

// ========== DATA FUNCTIONS ==========

void BookingTimelinePage::loadFieldsData()
{
    if (!m_quanLySan) return;
    
    m_fieldsMap.clear();
    m_field7To5Map.clear();
    
    const MangDong<San*> &allFields = m_quanLySan->layDanhSachSan();
    
    // Nh√≥m s√¢n 5 theo khu v·ª±c
    QMap<QString, QList<San*>> field5ByArea;
    QList<San*> field7List;
    
    for (int i = 0; i < allFields.size(); i++) {
        San *san = allFields[i];
        if (!san) continue;
        
        QString maSan = QString::fromStdString(san->getMaSan());
        m_fieldsMap[maSan] = san;
        
        if (san->layLoaiSan() == LoaiSan::SAN_5) {
            QString khuVuc = QString::fromStdString(san->layTenKhuVuc());
            field5ByArea[khuVuc].append(san);
        } else if (san->layLoaiSan() == LoaiSan::SAN_7) {
            field7List.append(san);
        }
    }
    
    // T·∫°o mapping s√¢n 7 -> 3 s√¢n 5 li·ªÅn k·ªÅ
    for (San *san7 : field7List) {
        QString maSan7 = QString::fromStdString(san7->getMaSan());
        QString khuVuc = QString::fromStdString(san7->layTenKhuVuc());
        
        // L·∫•y 3 s√¢n 5 ƒë·∫ßu ti√™n c√πng khu v·ª±c
        QList<San*> fields5InArea = field5ByArea[khuVuc];
        QList<QString> field5Ids;
        
        for (int i = 0; i < qMin(3, fields5InArea.count()); i++) {
            field5Ids << QString::fromStdString(fields5InArea[i]->getMaSan());
        }
        
        if (field5Ids.count() == 3) {
            m_field7To5Map[maSan7] = field5Ids;
        }
    }
    
    // Update field combo
    onFieldTypeChanged(m_fieldTypeCombo->currentText());
    
    // Update timeline columns
    populateFieldColumns();
}

void BookingTimelinePage::populateFieldColumns()
{
    QStringList headers;
    headers << "Time Slot";
    
    // Add all fields to columns
    for (auto it = m_fieldsMap.begin(); it != m_fieldsMap.end(); ++it) {
        San *san = it.value();
        QString displayName = QString::fromStdString(san->getTenSan());
        headers << displayName;
    }
    
    m_timelineTable->setColumnCount(headers.count());
    m_timelineTable->setHorizontalHeaderLabels(headers);
}

void BookingTimelinePage::loadBookingsData()
{
    if (!m_quanLyDatSan) return;
    
    // TODO: Load bookings t·ª´ QuanLyDatSan
    // S·∫Ω implement sau khi c√≥ API
}

void BookingTimelinePage::updateTimeline()
{
    // Clear all cells (except time slot column)
    for (int row = 0; row < m_timelineTable->rowCount(); row++) {
        for (int col = 1; col < m_timelineTable->columnCount(); col++) {
            QTableWidgetItem *item = m_timelineTable->item(row, col);
            if (!item) {
                item = new QTableWidgetItem("");
                m_timelineTable->setItem(row, col, item);
            }
            
            // Get field ID from header
            QString fieldName = m_timelineTable->horizontalHeaderItem(col)->text();
            
            // Check if booked
            bool isBooked = false; // TODO: Check from data
            
            if (isBooked) {
                item->setBackground(QBrush(QColor(COLOR_BOOKED)));
                item->setForeground(QBrush(Qt::white));
                item->setText("BOOKED");
                item->setTextAlignment(Qt::AlignCenter);
                item->setFlags(item->flags() & ~Qt::ItemIsEditable);
            } else {
                item->setBackground(QBrush(QColor(COLOR_AVAILABLE)));
                item->setText("");
                item->setFlags(item->flags() | Qt::ItemIsEditable);
            }
        }
    }
}

// ========== HELPER FUNCTIONS ==========

QWidget* BookingTimelinePage::createBookingCell(const QString &fieldId, int timeSlot)
{
    QWidget *cell = new QWidget();
    QVBoxLayout *layout = new QVBoxLayout(cell);
    layout->setContentsMargins(2, 2, 2, 2);
    
    bool isAvailable = isFieldAvailable(fieldId, m_selectedDate, timeSlot);
    
    if (isAvailable) {
        cell->setStyleSheet("background-color: " + COLOR_AVAILABLE + ";");
        QLabel *label = new QLabel("Available");
        label->setAlignment(Qt::AlignCenter);
        label->setStyleSheet("color: #999;");
        layout->addWidget(label);
    } else {
        cell->setStyleSheet("background-color: " + COLOR_BOOKED + ";");
        QLabel *label = new QLabel("Booked");
        label->setAlignment(Qt::AlignCenter);
        label->setStyleSheet("color: white; font-weight: bold;");
        layout->addWidget(label);
    }
    
    return cell;
}

bool BookingTimelinePage::isFieldAvailable(const QString &fieldId, const QDate &date, int timeSlot)
{
    Q_UNUSED(fieldId);
    Q_UNUSED(date);
    Q_UNUSED(timeSlot);
    // TODO: Implement check t·ª´ QuanLyDatSan
    return true; // M·∫∑c ƒë·ªãnh l√† tr·ªëng
}

QList<QString> BookingTimelinePage::get3ConsecutiveFields(const QString &fieldId7)
{
    return m_field7To5Map.value(fieldId7, QList<QString>());
}

// ========== SEARCH FUNCTIONS ==========

void BookingTimelinePage::searchCustomerByPhone(const QString &phone)
{
    Q_UNUSED(phone);
    if (!m_quanLyKhachHang) return;
    
    // TODO: T√¨m kh√°ch h√†ng theo s·ªë ƒëi·ªán tho·∫°i
    // KhachHang *kh = m_quanLyKhachHang->timKhachHang(phone.toStdString());
    // if (kh) {
    //     m_nameEdit->setText(QString::fromStdString(kh->getTen()));
    // }
}

// ========== BOOKING LOGIC ==========

void BookingTimelinePage::handleCellClick(const QString &fieldId, int timeSlot)
{
    m_selectedFieldId = fieldId;
    m_selectedTimeSlot = timeSlot;
    
    // Update form v·ªõi th√¥ng tin slot ƒë∆∞·ª£c ch·ªçn
    if (timeSlot >= 0 && timeSlot < m_timeSlots.count()) {
        QString timeStr = m_timeSlots[timeSlot];
        QTime time = QTime::fromString(timeStr, "HH:mm");
        m_fromTimeEdit->setTime(time);
        m_toTimeEdit->setTime(time.addSecs(3600 * 2)); // +2 hours
    }
    
    // TODO: Check if cell is already booked and load booking info
}

void BookingTimelinePage::createQuickBooking(const QString &fieldId, int timeSlot)
{
    Q_UNUSED(fieldId);
    Q_UNUSED(timeSlot);
    // TODO: Quick booking logic
}

void BookingTimelinePage::validateAndSaveBooking()
{
    // Validation
    if (m_phoneEdit->text().isEmpty()) {
        QMessageBox::warning(this, "L·ªói Nh·∫≠p Li·ªáu", "Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i kh√°ch h√†ng!");
        return;
    }
    
    if (m_nameEdit->text().isEmpty()) {
        QMessageBox::warning(this, "L·ªói Nh·∫≠p Li·ªáu", "Vui l√≤ng nh·∫≠p t√™n kh√°ch h√†ng!");
        return;
    }
    
    if (m_fieldCombo->currentText().isEmpty()) {
        QMessageBox::warning(this, "L·ªói Nh·∫≠p Li·ªáu", "Vui l√≤ng ch·ªçn s√¢n!");
        return;
    }
    
    // TODO: Save booking
    QMessageBox::information(this, "Th√†nh C√¥ng", "ƒê·∫∑t s√¢n th√†nh c√¥ng!");
    
    // Refresh timeline
    updateTimeline();
}

bool BookingTimelinePage::checkField7Availability(const QString &fieldId7, const QDate &date, int timeSlot)
{
    QList<QString> field5Ids = get3ConsecutiveFields(fieldId7);
    
    if (field5Ids.count() != 3) {
        return false;
    }
    
    // Check all 3 fields are available
    for (const QString &field5Id : field5Ids) {
        if (!isFieldAvailable(field5Id, date, timeSlot)) {
            return false;
        }
    }
    
    return true;
}

// ========== SLOTS ==========

void BookingTimelinePage::onDateChanged(const QDate &date)
{
    m_selectedDate = date;
    m_dateEdit->setDate(date);
    updateTimeline();
}

void BookingTimelinePage::onPhoneSearchClicked()
{
    QString phone = m_phoneEdit->text().trimmed();
    if (!phone.isEmpty()) {
        searchCustomerByPhone(phone);
    }
}

void BookingTimelinePage::onFieldTypeChanged(const QString &type)
{
    m_fieldCombo->clear();
    
    LoaiSan loaiSan = (type == "S√¢n 5 ng∆∞·ªùi") ? LoaiSan::SAN_5 : LoaiSan::SAN_7;
    
    for (auto it = m_fieldsMap.begin(); it != m_fieldsMap.end(); ++it) {
        San *san = it.value();
        if (san->layLoaiSan() == loaiSan && san->dangHoatDong()) {
            QString displayName = QString::fromStdString(san->getTenSan());
            m_fieldCombo->addItem(displayName, QString::fromStdString(san->getMaSan()));
        }
    }
}

void BookingTimelinePage::onSaveClicked()
{
    validateAndSaveBooking();
}

void BookingTimelinePage::onDeleteClicked()
{
    auto reply = QMessageBox::question(this, "X√°c Nh·∫≠n X√≥a", 
                                       "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ƒë∆°n ƒë·∫∑t n√†y?",
                                       QMessageBox::Yes | QMessageBox::No);
    
    if (reply == QMessageBox::Yes) {
        // TODO: Delete booking
        QMessageBox::information(this, "Th√†nh C√¥ng", "X√≥a ƒë∆°n ƒë·∫∑t th√†nh c√¥ng!");
        updateTimeline();
    }
}

void BookingTimelinePage::onCheckInClicked()
{
    // TODO: Check-in logic
    QMessageBox::information(this, "Check-in", "Ch·ª©c nƒÉng check-in s·∫Ω s·ªõm ƒë∆∞·ª£c ho√†n thi·ªán!");
}

void BookingTimelinePage::onTimelineRefresh()
{
    loadBookingsData();
    updateTimeline();
}

void BookingTimelinePage::onTimeRangeSelected(int fieldColumn, int startRow, int endRow)
{
    // L·∫•y th√¥ng tin s√¢n t·ª´ header
    QString fieldName = m_timelineTable->horizontalHeaderItem(fieldColumn)->text();
    
    // T√≠nh th·ªùi gian b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c (30 ph√∫t/slot)
    QString startTime = m_timeSlots[startRow];
    QString endTime;
    
    // endRow + 1 v√¨ k√©o ƒë·∫øn row ƒë√≥, c·ªông th√™m 30 ph√∫t
    if (endRow + 1 < m_timeSlots.count()) {
        endTime = m_timeSlots[endRow + 1];
    } else {
        // N·∫øu k√©o ƒë·∫øn cu·ªëi, th√™m 30 ph√∫t v√†o time cu·ªëi c√πng
        QTime lastTime = QTime::fromString(m_timeSlots[endRow], "HH:mm");
        endTime = lastTime.addSecs(1800).toString("HH:mm"); // +30 minutes
    }
    
    // C·∫≠p nh·∫≠t form v·ªõi th√¥ng tin ƒë√£ ch·ªçn
    m_dateEdit->setDate(m_selectedDate);
    m_fromTimeEdit->setTime(QTime::fromString(startTime, "HH:mm"));
    m_toTimeEdit->setTime(QTime::fromString(endTime, "HH:mm"));
    
    // T√¨m v√† ch·ªçn s√¢n trong combo
    for (int i = 0; i < m_fieldCombo->count(); i++) {
        if (m_fieldCombo->itemText(i) == fieldName) {
            m_fieldCombo->setCurrentIndex(i);
            break;
        }
    }
    
    // Show notification
    QMessageBox::information(this, "ƒê√£ Ch·ªçn Kho·∫£ng Th·ªùi Gian", 
        QString("ƒê√£ ch·ªçn:\nS√¢n: %1\nTh·ªùi gian: %2 - %3\n\nVui l√≤ng nh·∫≠p th√¥ng tin kh√°ch h√†ng v√† nh·∫•n L∆∞u.")
        .arg(fieldName).arg(startTime).arg(endTime));
}
